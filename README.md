# A Profiler for Java Programs

A source-code-instrumentation profiler for Java programs.
Designed to be a single-JAR command line tool that generates HTML reports. 
Optionally, a JavaFX GUI is available to configure the parameters and run the tool automatically.

The tool can parse Java **17** language syntax and also should be executed with a JDK of version 17+.

## Quick links:
- [Introduction](#introduction)
- [Download](#download)
- [Building from source](#building-from-source)
- [Usage](#usage)
- [FxUI](#fxui)
- [Report](#report)
- [Implementation details](#implementation-details)
- [Dependencies](#dependencies)
- [Future work and ideas](#future-work-and-ideas)

# Introduction

This project was created as part of my master's thesis at the Institute for System Software ([SSW](https://ssw.jku.at/)) 
of the Johannes Kepler University ([JKU](https://www.jku.at/)), located in Linz, Austria.

The profiler instruments source code directly (as opposed to commonly used bytecode instrumentation) 
by inserting counter statements at the beginning of every executable code block.
<br/>
Blocks are found by parsing files with a Scanner+Parser generated by the [Coco/R](https://ssw.jku.at/Research/Projects/Coco/) tool.

The intention for the attributed Grammar (ATG), used in this project, was to be kept of minimal size 
and complexity by applying "fuzzy" parsing. This should improve maintainability with the constantly 
updating and growing [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se17/html/index.html).

In the default mode, this tool instruments source files automatically, compiles them, 
runs the program (with arguments), and generates an HTML report. 
The report provides a structured and sorted overview over the number of method invocations by class. 
It further allows exploration of source files and shows coverage (with counts) of (grouped) statements regions.

The profiler was designed to be a command line tool that can easily be used in scripts, CI/CD pipelines and automations.

For Java/programming beginners, or users who are less familiar with the command line, 
a JavaFX tool-runner GUI was created (see [FxUI](#fxui) section).


## Download
The [Releases](https://github.com/matwoess/java-profiler/releases/) section contains downloadable `.jar`-archives for the tool and the FxUI tool-runner.

The UI has separate releases for Windows, Linux and MacOS.
<br/>
The "fxui" zip archives provide executable scripts to directly start the GUI without using the command line.

## Building from source
To build the project from source, Gradle and a Java JDK of version 17 or newer are required.

After cloning or downloading the repository, the `Scanner.java` and `Parser.java` files must first 
be generated using the [Coco/R library](https://ssw.jku.at/Research/Projects/Coco/Java/Coco.jar).

This can be done automatically by running the provided `generate-parser.sh`  bash script, 
or the `generate-parser.ps1` PowerShell script in the [scripts/](scripts/) folder. 

Both should automatically download the library and execute it on the project's [ATG file](profiler-tool/src/main/java/tool/instrument/JavaFile.atg).

This can also be done manually by downloading the library and executing the following command in the project root, 
to re-generate the parser files at any time:
```shell
java -jar lib/Coco.jar -package tool.instrument profiler-tool/src/main/java/tool/instrument/JavaFile.atg 
```
## Usage
```
Usage: profiler [options] <main file> [program args]  
Or   : profiler [options] <run mode>
```
The Java binaries `java` and `javac` should be included in the system environment path variable for it to work.

All output is stored in the hidden `.profiler` subdirectory of the current working directory.

For being able to used local project resources and relative paths, as arguments or inside the program,
the tool never changes its directory and makes use of classpath arguments instead.

As soon as Main file references another source file, the `-d`/`--sources-directory` parameter is **required**!

### Sample usage and explanation
(In the below section the `java -jar profiler.jar` command is substituted by `profiler`)

In the simplest case, the tool can be used as following:
```shell
profiler Main.java arg1 arg2 ...
```
This will parse the given file and create an instrumented copy in the `.profiler/instrumented/` folder. 
The first argument for the tool specifies the class containing the main entry point.
<br/>
Additionally the `.profiler/metadata.dat` file will be created, containing information about the begin/end 
of every found block and its parent method and class.

The tool will automatically compile the instrumented version using `javac`.
```shell
javac -cp .profiler/instrumented -d .profiler/classes Main.java
```
The Java compiler finds referenced Java files used in Main itself and will compile them also 
into (instrumented) `.class` files.
<br>
The compiled classes can be found in the `.profiler/classes/` directory.

Next, the java binary will be used to execute the specified class by name (without the `.java` extension) 
with the specified arguments:
```
java -cp .profiler/classes Main arg1 arg2 ...
```
Executing the instrumented files, automatically stores the hit-counter values in `.profiler/counts.dat`, 
as soon as the program ends (if at least 1 counter was inserted).

Finally, the metadata and counts will be used to create the report inside `.profiler/report/`.

### Command line options
There are a few optional arguments available. For a full list, run `profiler -h` or `profiler --help`.

#### sources-directory
As soon as the project-to-profile consists of two or more (linked) Java files, the sources directory has to be specified.
This is done with the `-d` or `--sources-directory` option:
```shell
profiler -d src/main/java/ src/main/java/subfolder/Main.java
```

Using this option, all `.java` files inside `src/main/java/` will be parsed, instrumented and copied to the 
"instrumented" directory. The relative folder-structure is replicated to ensure successful compilation (`javac` will
throw an error if the package name and file paths mismatch).

#### synchronized
When adding `-s` or `--synchronized` as a option, all inserted counters will be incremented atomically. 
This might be useful for multi-threaded programs, where a few methods or blocks are constantly executed in parallel.
It will ensure that hit counts are correct, but runtime performance will be impacted.

#### verbose
This option is mainly for debugging purposes. It can be activated with `-v` or `--verbose` and will output 
detailed information about the parsing process for each file.

### Run modes

The tool is primarily designed for easy usage with small projects that have a Main file. 
In case the project cannot be compiled with `javac Main.java`, or usage of build tools (like Maven, Gradle, or Ant), 
we cannot use the default compilation logic.

For this case, two additional run modes are available:

#### instrument-only

By specifying the `-i <file|dir>` or `--instrument-only <file|dir>` mode, the target file or directory, 
with all its Java files, will be instrumented and added to the `.profiler/instrumented/` directory. 
Also, the `metadata.dat` file is generated.

It can then be compiled by custom commands and run manually
(automatic copying of `pom.xml` or gradle files is currently not done).

#### generate-report-only

If a project was already instrumented and run, the HTML report can be quickly (re-)generated 
with the `-r` or `--generate-report` run mode.
In this mode, no parsing or instrumentation will be done.
For it to succeed the `metadata.dat` and `counts.dat` files must already exist in the output directory.

## FxUI

A graphical application (using th [JavaFX](https://openjfx.io/) toolkit) was created, to easily configure parameters and arguments 
for the command-line tool. The profiler is then executed in a terminal.

Golden `(?)` labels can be hovered over for more information about each field.

### Open project dialog

Before displaying the main window, a project directory must be chosen, using a selection dialog.

![FxUI project dialog](https://i.ibb.co/5K2gZwf/project-dialog.png)

Clicking "Select" will show the system's native dialog to choose a folder.
<br/>
Alternatively the path can be entered manually.

As soon as a valid folder path is entered, the main window can be started with the "Open" button.

On the next program execution, the previously opened path will be pre-filled.

### Main window

![FxUI preview](https://i.ibb.co/Tkcz5wX/Screenshot-from-2023-11-20-22-36-27.png)


Using the file tree on the left, the sources directory and main file can be selected. Depending on the run mode 
this may be required.
<br/>
Assigning a file or directory to a parameter can be done with the <kbd>Return</kbd> key, or using the context menu
on a tree item.

The tree highlights important items in color:
- blue - selected sources directory,
- green - selected main file.
- brown - output directory

The menu bar allows rebuilding the file tree, and saving or restoring currently set parameters (will be saved in the 
output directory as `parameters.dat`).

When clicking "Run tool", a system-native terminal (can be chosen) will be opened, to show program output and 
to allow user input (for interactive programs).

The executed command can be previewed with the "Preview command" button.

"Open report" will only show up once the `.profiler/report/index.html` file exists, and calls the systems default
application for files of type `.html`.

### Theme

The UI uses the `PrimerDark` theme from [AtlantaFX](https://github.com/mkpaz/atlantafx) as a `userAgentStylesheet`.

## Report

In the default run mode (or using the `-r` mode) an HTML report will be generated inside the output directory.

It is stored in the `.profiler/report/` folder. The `index.html` file can be opened in a browser to view it.

### Classes (index.html)

The main index lists all classes found during parsing.
<br/>
The list is sorted by the aggregated count of each class's method invocations.

![Report classes overview](https://i.ibb.co/42vWFsk/Screenshot-from-2023-11-30-20-01-24.png)

This can be useful for finding hotspots in the program during a typical run, but also to identify unused code.

Clicking on the clas name will open the "Methods" index for this specific class.
<br/>
By clicking on the source file name, we can jump directory to the coverage report of that file.

### Methods (index_ClassName.html)

A separate method index is created for each *top-level* class.
<br/>
It lists each non-abstract method, sorted by invocation count.

![Report methods overview](https://i.ibb.co/dcRwt6M/Screenshot-from-2023-11-30-20-10-28.png)

The heading includes the fully qualified name of the class.

Methods of inner classes are shown with the java class-file syntax: `Outer$Inner::Method`.
<br/>
Anonymous inner classes get a numbered name `Outer$3::Method`, just like in the java bytecode.

Clicking on a method name will jump to the source coverage report, to the exact line number of declaration.

Browser-back can be used to return to the classes index.

### Source file detail report (JavaFileName.html)

For each Java file, an annotated HTML source code file is generated. It can be used explore each class 
and its method in detail.

A small [jQuery](https://jquery.com/) JavaScript [file](profiler-tool/src/main/resources/highlighter.js) initializes 
colors for relevant sections and dynamically updates them on hovering.

![Report source file](https://i.ibb.co/59QpdP3/source-file.png)

Code blocks that have been entered at least once during program execution are highlighted in green. 
<br/>
Not covered blocks are displayed with red background color.

Statements with the same hit count are grouped into "code regions".
<br/>
These regions are shown in a darker, more opaque green or red (depending on their coverage status).

The column, to the left of line numbers, contains the region counts for each line.
<br/>
If multiple code regions are located in the same line, the hits are shown stacked next to each other.

Hovering over a block or region will highlight the entire block in orange and the current region in dark-orange.
<br/>
The current region's code text will also become bold until moving the mouse away from the region.
<br/>
Additionally a popup-hint will show the number of hits.

## Implementation details

// TODO

## Dependencies

// TODO

## Future work and ideas

// TODO
