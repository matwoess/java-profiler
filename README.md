# A Profiler for Java Programs

A source-code-instrumentation profiler for Java programs.
Designed to be a single-JAR command line tool that generates HTML reports. 
Optionally, a JavaFX GUI is available to configure the parameters and run the tool automatically.

The tool can parse Java **17** language syntax and also should be executed with a JDK of version 17+.

## Quick links:
- [Introduction](#introduction)
- [Download](#download)
- [Building from source](#building-from-source)
- [Usage](#usage)
- [FxUI](#fxui)
- [Report](#report)
- [Implementation details](#implementation-details)
- [Dependencies](#dependencies)
- [Future work and ideas](#future-work-and-ideas)

# Introduction

This project was created as part of my master's thesis at the Institute for System Software ([SSW](https://ssw.jku.at/)) 
of the Johannes Kepler University ([JKU](https://www.jku.at/)), located in Linz, Austria.

The profiler instruments source code directly (as opposed to commonly used bytecode instrumentation) 
by inserting counter-statements at the beginning of every executable code block.
<br/>
Blocks are found by parsing files with a Scanner+Parser generated by the [Coco/R](https://ssw.jku.at/Research/Projects/Coco/) tool.

The intention for the attributed Grammar (ATG), used in this project, was to be kept of minimal size 
and complexity by applying "fuzzy" parsing. This should improve maintainability with the constantly 
updating and growing [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se17/html/index.html).

In the default mode, this tool instruments source files automatically, compiles them, 
runs the program (with arguments), and generates an HTML report. 
The report provides a structured and sorted overview over the number of method invocations by class. 
It further allows exploration of source files and shows coverage (with counts) of (grouped) statements regions.

The profiler was designed to be a command line tool that can easily be used in scripts, CI/CD pipelines and automations.

For Java/programming beginners, or users who are less familiar with the command line, 
a JavaFX tool-runner GUI was created (see [FxUI](#fxui) section).


## Download
The [Releases](https://github.com/matwoess/java-profiler/releases/) section contains downloadable `.jar`-archives for the tool and the FxUI tool-runner.

The UI has separate releases for Windows, Linux and MacOS.
<br/>
The "fxui" zip archives provide executable scripts to directly start the GUI without using the command line.

## Building from source
To build the project from source, Gradle and a Java JDK of version 17 or newer are required.

After cloning or downloading the repository, the `Scanner.java` and `Parser.java` files must first 
be generated using the [Coco/R library](https://ssw.jku.at/Research/Projects/Coco/Java/Coco.jar).

This can be done automatically by running the provided `generate-parser.sh`  bash script, 
or the `generate-parser.ps1` PowerShell script in the [scripts/](scripts/) folder. 

Both should automatically download the library and execute it on the project's [ATG file](profiler-tool/src/main/java/tool/instrument/JavaFile.atg).

This can also be done manually by downloading the library and executing the following command in the project root, 
to re-generate the parser files at any time:
```shell
java -jar lib/Coco.jar -package tool.instrument profiler-tool/src/main/java/tool/instrument/JavaFile.atg 
```
## Usage
```
Usage: profiler [options] <main file> [program args]  
Or   : profiler [options] <run mode>
```
The Java binaries `java` and `javac` should be included in the system environment path variable for it to work.

All output is stored in the hidden `.profiler` subdirectory of the current working directory.

For being able to use local project resources and relative paths, as arguments or inside the program,
the tool never changes its directory and makes use of classpath arguments instead.

As soon as the Main file references another source file, the `-d`/`--sources-directory` parameter is **required**!

### Sample usage and explanation
(In the below section the `java -jar profiler.jar` command is substituted by `profiler`)

In the simplest case, the tool can be used as following:
```shell
profiler Main.java arg1 arg2 ...
```
This will parse the given file and create an instrumented copy in the `.profiler/instrumented/` folder. 
The first argument for the tool specifies the class containing the main entry point.
<br/>
Additionally the `.profiler/metadata.dat` file will be created, containing information about the begin/end 
of every found block and its parent method and class.

The tool will automatically compile the instrumented version using `javac`.
```shell
javac -cp .profiler/instrumented -d .profiler/classes Main.java
```
The Java compiler finds referenced Java files used in Main itself and will compile them also 
into (instrumented) `.class` files.
<br>
The compiled classes can be found in the `.profiler/classes/` directory.

Next, the java binary will be used to execute the specified class by name (without the `.java` extension) 
with the specified arguments:
```
java -cp .profiler/classes Main arg1 arg2 ...
```
Executing the instrumented files, automatically stores the hit-counter values in `.profiler/counts.dat`, 
as soon as the program ends (if at least one counter was inserted).

Finally, the metadata and counts will be used to create the report inside `.profiler/report/`.

### Command line options
There are a few optional arguments available. For a full list, run `profiler -h` or `profiler --help`.

#### sources-directory
As soon as the project-to-profile consists of two or more (linked) Java files, the sources directory has to be specified.
This is done with the `-d` or `--sources-directory` option:
```shell
profiler -d src/main/java/ src/main/java/subfolder/Main.java
```

Using this option, all `.java` files inside `src/main/java/` will be parsed, instrumented and copied to the 
"instrumented" directory. The relative folder-structure is replicated to ensure successful compilation (`javac` will
throw an error if the package name and file paths mismatch).

#### synchronized
When adding `-s` or `--synchronized` as a option, all inserted counters will be incremented atomically. 
This might be useful for multi-threaded programs, where a few methods or blocks are constantly executed in parallel.
It will ensure that hit counts are correct, but runtime performance will be impacted.

#### verbose
This option is mainly for debugging purposes. It can be activated with `-v` or `--verbose` and will output 
detailed information about the parsing process for each file.

### Run modes

The tool is primarily designed for easy usage with small projects that have a Main file. 
In case the project cannot be compiled with `javac Main.java`, or usage of build tools (like Maven, Gradle, or Ant), 
we cannot use the default compilation logic.

For this case, two additional run modes are available:

#### instrument-only

By specifying the `-i <file|dir>` or `--instrument-only <file|dir>` mode, the target file or directory, 
with all its Java files, will be instrumented and added to the `.profiler/instrumented/` directory. 
Also, the `metadata.dat` file is generated.

It can then be compiled by custom commands and run manually
(automatic copying of `pom.xml` or gradle files is currently not done).

#### generate-report-only

If a project was already instrumented and run, the HTML report can be quickly (re-)generated 
with the `-r` or `--generate-report` run mode.
In this mode, no parsing or instrumentation will be done.
For it to succeed the `metadata.dat` and `counts.dat` files must already exist in the output directory.

## FxUI

A graphical application (using th [JavaFX](https://openjfx.io/) toolkit) was created, to easily configure parameters and arguments 
for the command-line tool. The profiler is then executed in a terminal.

Golden `(?)` labels can be hovered over for more information about each field.

### Open project dialog

Before displaying the main window, a project directory must be chosen, using a selection dialog.

![FxUI project dialog](https://i.ibb.co/5K2gZwf/project-dialog.png)

Clicking "Select" will show the system's native dialog to choose a folder.
<br/>
Alternatively the path can be entered manually.

As soon as a valid folder path is entered, the main window can be started with the "Open" button.

On the next program execution, the previously opened path will be pre-filled.

### Main window

![FxUI preview](https://i.ibb.co/Tkcz5wX/Screenshot-from-2023-11-20-22-36-27.png)


Using the file tree on the left, the sources directory and main file can be selected. Depending on the run mode 
this may be required.
<br/>
Assigning a file or directory to a parameter can be done with the <kbd>Return</kbd> key, or using the context menu
on a tree item.

The tree highlights important items in color:
- blue - selected sources directory,
- green - selected main file.
- brown - output directory

The menu bar allows rebuilding the file tree, and saving or restoring currently set parameters (will be saved in the 
output directory as `parameters.dat`).

When clicking "Run tool", a system-native terminal (can be chosen) will be opened, to show program output and 
to allow user input (for interactive programs).

The executed command can be previewed with the "Preview command" button.

"Open report" will only show up once the `.profiler/report/index.html` file exists, and calls the systems default
application for files of type `.html`.

### Theme

The UI uses the `PrimerDark` theme from [AtlantaFX](https://github.com/mkpaz/atlantafx) as a `userAgentStylesheet`.

## Report

In the default run mode (or using the `-r` mode) an HTML report will be generated inside the output directory.

It is stored in the `.profiler/report/` folder. The `index.html` file can be opened in a browser to view it.

### Classes (index.html)

The main index lists all classes found during parsing.
<br/>
The list is sorted by the aggregated count of each class's method invocations.

![Report classes overview](https://i.ibb.co/42vWFsk/Screenshot-from-2023-11-30-20-01-24.png)

This can be useful for finding hotspots in the program during a typical run, but also to identify unused code.

Clicking on the clas name will open the "Methods" index for this specific class.
<br/>
By clicking on the source file name, we can jump directory to the coverage report of that file.

### Methods (index_ClassName.html)

A separate method index is created for each *top-level* class.
<br/>
It lists each non-abstract method, sorted by invocation count.

![Report methods overview](https://i.ibb.co/dcRwt6M/Screenshot-from-2023-11-30-20-10-28.png)

The heading includes the fully qualified name of the class.

Methods of inner classes are shown with the java class-file syntax: `Outer$Inner::Method`.
<br/>
Anonymous inner classes get a numbered name `Outer$3::Method`, just like in the java bytecode.

Clicking on a method name will jump to the source coverage report, to the exact line number of declaration.

Browser-back can be used to return to the classes index.

### Source file detail report (JavaFileName.html)

For each Java file, an annotated HTML source code file is generated. It can be used explore each class 
and its method in detail.

A small [jQuery](https://jquery.com/) JavaScript [file](profiler-tool/src/main/resources/highlighter.js) initializes 
colors for relevant sections and dynamically updates them on hovering.

![Report source file](https://i.ibb.co/59QpdP3/source-file.png)

Code blocks that have been entered at least once during program execution are highlighted in green. 
<br/>
Not covered blocks are displayed with red background color.

Statements with the same hit count are grouped into "code regions".
<br/>
These regions are shown in a darker, more opaque green or red (depending on their coverage status).

The column, to the left of line numbers, contains the region counts for each line.
<br/>
If multiple code regions are located in the same line, the hits are shown stacked next to each other.

Hovering over a block or region will highlight the entire block in orange and the current region in dark-orange.
<br/>
The current region's code text will also become bold until moving the mouse away from the region.
<br/>
Additionally a popup-hint will show the number of hits.

## Implementation details

This sections gives some more info on how the profiler works in detail.

### Grammar/Parser
The Grammar consists of a reduced set of non-terminal symbols (NTS) that covers the most important aspects 
of the Java 17 syntax tailored for this usecase (finding block begin/end positions).

Using Coco's `ANY` keyword, we over-read non-relevant tokens like:
- access modifiers (`public`, `private`, ... )
- interfaces that a class `implements`
- class level constants and member variables
- generic types `<Type1<Type2,...>, ...>`
- array initializer blocks (start with `{`, but we cannot insert counters here)
- the argument list of a method inside parenthesis
  <br/>
  e.g.: `void meth(arg1, arg2, ...) {` will be read as `ident` `ident` `ParExpr` `{`
- remaining tokens in a `GenericStatement` until `;`
- constants and expressions for switch cases before the `:`
- ...

To build an index of classes and their methods, we have to keep track of class names and method names in each 
file and assign them to the blocks of the model.
<br/>
Also, package declarations at the beginning of a file will be inherited to any class in this file for knowing its 
fully qualified name.

### ParserState

This class is directly associated with our grammar and carries most of the instrumentation logic.
<br/>
This way, the grammar file isn't cluttered and can be easily re-used.

The state class keeps track of relevant information like the current class, method, block and region during parsing.
<br/>
It assigns beginning-, and end-character-positions and line numbers to the model, stores a list for all
found blocks inside a file and is responsible for building a file's metadata.

Using context actions in our ATG with the Coco/R syntax `(. helperMethod() .)` we inject the ParserState methods
into our grammar; that will be inserted automatically into the generated Parser class.

The `Instrumenter` calls an instance of `Parser` on every Java file and extracts all relevant data form 
the `ParserState`'s member variables afterward.

## Instrumentation
The tool parses source code files and stores an instrumented copy in the output directory.

At the beginning of executable code blocks (usually after an opening brace `{`). a `__Counter.inc(X);` statement is
inserted.

A program like:
```java
class Class {
  void meth() {
    if (...) { ... }
    while (...) { ... }
    switch (...) {
      case VAL:
        ...
        break;
      default:
        ...
        break;
    }
  }
}
```

Would look in its instrumented version something like this:
```java
class Class {
  void meth() {__Counter.inc(78);
    if (...) {__Counter.inc(79); ... }
    while (...) {__Counter.inc(80); ... }
    switch (...) {
      case VAL:__Counter.inc(81);
        ...
        break;
      default:__Counter.inc(82);
        ...
        break;
    }
  }
}

```

### The `__Counter` class

For all the calls to the Counter's `inc` method to compile,
we need to import our counter-class in each instrumented file.
These import statements are inserted at the beginning of each file (after the package declaration).

For it to work with Java 9+ versions (enforcing package declarations), it was packed into an `auxiliary` package.

A compiled `.class` version of `Counter` is extracted from the tool JAR and copied
to the `instrumented/` directory. This ensures successful compilation of the instrumented sources.

After compilation, it is also copied to the `classes/` directory for avoiding additional class-path arguments.

The counter-class keeps an integer-array, the size of all found blocks in the entire project.
<br/>
Every `__Counter.inc(idx)` statement includes the block-index to increment.

By default, calls to `inc` are not synchronized to speed up runtime performance.
<br/>
The class also contains `incSync` variants that lock the class object before incrementing, to ensure exact results 
in multi-threaded programs.


### Special cases

Some language structures require non-trivial special handling.

#### Single-statements

We cannot just add a counter-statement for single-statement blocks. 
<br/>
In this case, we have to wrap the block in braces for it to compile.

```java
public void ... {
  int x = 0;
  if (true)
    if (...) x++ else x--;
  while(...) x = 1;
  do x++; while(..);
  for(;;) x--;
  ...
}
```

would require insertion of:

```java
public void ... {
  int x = 0;
  if (true)'{__C.inc(0);'
    if (...)'{__C.inc(1);' x++'}' else'{__C.inc(2);' x--;'} }'
  while(...)'{__C.inc(3);' x = 1;'}'
  do'{__C.inc(4);' x++;'}' while(..);
  for(;;)'{__C.inc(5);' x--;'}'
  ...
}
```

#### Brace-less Lambdas

Especially for stream processing, lambda statements are often used without a method body.

Given the example:

```java
integers.stream()
        .peek(x -> System.out.println(x))
        .filter(x -> x % 2 == 0)
        .sum()
```

we need a clever way to observe how often each lambda statement was executed.

The `__Counter` class contains a special `incLambda` method that wraps these lambdas in a `Runnable` or generic
`Supplier<T>` argument.

The instrumented version will look like this:

```java
integers.stream()
        .peek(x ->'__Counter.incLambda(61, () ->' System.out.println(x)')')
        .filter(x ->'__Counter.incLambda(62, () ->'  x % 2 == 0')')
        .sum()
```

The compiler will automatically choose the fitting `incLambda` variant to call, depending on the return type.

#### Single-statement switch-expression arrow-cases

Switch expression must return a value.
<br/>
If the arrow-case has braces, the `yield` statement must be used to return this value from the expression.
<br/>
Should the case body have no braces, we need to insert them.
Therefore, we also need to add a `yield` statement. 
<br/>
In case a branch throws an exception, `yield` must **not** be added.

The following example:

```java
StatusCode statusCode = ...;
int sc = switch (statusCode) {
  case OK -> 200;
  case UNAUTHORIZED -> 401;
  case FORBIDDEN -> 403;
  case NOTFOUND -> { yield 404; }
  default -> throw new RuntimeException("invalid code");
};
```

is as following instrumented like this:

```java
StatusCode statusCode = ...;
int sc = switch (statusCode) {
  case OK ->'{__C.inc(5); yield' 200;'}'
  case UNAUTHORIZED ->'{__C.inc(6); yield' 401;'}'
  case FORBIDDEN ->'{__C.inc(7); yield' 403;'}'
  case NOTFOUND -> {'__C.inc(8);' yield 404; }
  default -> '{_C.inc(9);' throw new RuntimeException();'}'
};
```

### Constructor overloading and super calls

Another special case is constructors.

If a constructor calls another overloaded one with `this(arg, "fixed");`, or the parent class's constructor is called 
with `super(args)`, these statements **must** be the first ones in the method block.
Otherwise, the compiler will throw an error.

This makes it impossible to insert a `__Counter(X);` statement right after the method's opening brace.

To handle this special case, we need to keep track of the **end** position of possible first `this/super` calls 
in constructors.
The counter-statement is added only after this call. 

```java
class SmallDog extends Dog {
  public SmallDog(String name, int age) {
    super(name, age);'__Counter.inc(3);'
    size = Size.SMALL;
    super.speak();
  }
  SmallDog(String n, int age, Size s) {
    this(n, age);'__Counter.inc(4);'
    this.size = s;
  }
  ...
}
```

## Dependencies

// TODO

## Future work and ideas

// TODO
