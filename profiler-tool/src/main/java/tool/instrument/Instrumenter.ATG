COMPILER Instrumenter
	ParserState state = new ParserState(this);

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	tab = '\t'.
	letter = 'a'..'z' + 'A'..'Z' + '_'.
	digit  = '0'..'9'.
	bslash = '\\'.
	quote = '"'.
	apostrophe = '\''.
	noApostrophe = ANY - apostrophe- bslash - cr - lf.
 	noQuote = ANY - quote - bslash - cr - lf.
	escapableChar = 'b'+ 's' + 't' + 'n' + 'f' + 'r' + quote + apostrophe + bslash.
	hexDigit = digit + 'a'..'f' + 'A'..'F'.
	zeroToThree = "0123".
	octalDigit = "01234567".
TOKENS
	ident  = letter {letter | digit}.
	char =
		apostrophe (
			bslash (
				escapableChar
				| 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
				| (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
			)
			| noApostrophe
		) apostrophe.
	string =
		( quote quote quote lf {noQuote} quote quote quote
		| quote {(
				bslash (
					escapableChar
					| 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
					| (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
				)
				| noQuote
			)} quote
		).
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	classRef = ".class".  // exclude from being interpreted as new class definition
	this     = "this".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE tab + cr + lf

PRODUCTIONS

Instrumenter = [PackageDecl] { AnnotationType | Annotation | Class<false> | Enum<false> | ANY }.
PackageDecl = "package" (. ArrayList<String> packageName = new ArrayList<>(); .)
		ident 							(. packageName.add(t.val); .)
		{'.' ident 					(. packageName.add(t.val); .)
		}
		";" 								(. state.setPackageName(packageName); .)
		.
AnnotationType = "@interface" ident BraceExpr.
Annotation = "@" ident {"." ident} [ParExpr].
Class<boolean local> =
		("class" | "interface" | "record")	(. state.enterClass(false, local); .)
		ident {ANY} "{"
		ClassBody								(. state.leaveClass(); .)
	.
Enum<boolean local> =
	"enum"										(. state.enterClass(false, local); .)
	ident {ANY} "{"
	{ident [ParExpr] ["{" ClassBody] [","]}
	(";" ClassBody						// class body can follow only after a ";"
		| "}") 									(. state.leaveClass(); .)
	.
ClassBody =
	{ Enum<false> | Class<false>
		| "=" (BraceExpr | {ANY} Statement)
		| IF(state.identAndLPar()) MethodDecl
		| IF(state.classNameAndLBrace()) MethodDecl  // compact record constructor
		| IF(state.staticAndLBrace()) StaticBlock
		| AnnotationType | Annotation
		| ANY
	}
	"}"
.
StaticBlock =	"static" Block<false>.
MethodDecl =
		ident 							(. state.enterMethod(); .)
		{ANY} (";"					(. state.leaveMethod(); .)
			| Block<true>
			)
		.
Statement =
		"if" ParExpr BlockOrSingleStatement ["else" BlockOrSingleStatement]
		| SwitchStatement
		| "while" ParExpr BlockOrSingleStatement
 		| "do" BlockOrSingleStatement "while" ParExpr ";"
		| "for" ParExpr BlockOrSingleStatement
		| "try" [ParExpr] Block<false> {"catch" ParExpr Block<false>} ["finally" Block<false>]
		| ("break" | "continue") {ANY} ";"
		| ("return" | "yield") (SwitchStatement | {ANY}) ";"
		| IF(state.isLabel()) ident ":"
		| Annotation
		| "super" (ParExpr ";" (. state.markEndOfSuperCall(); .) | "." {ANY} ";")
		| IF(state.thisAndLPar()) this ParExpr ";" (. state.markEndOfSuperCall(); .)
		| ("++" | "--") ["("] ident [")"] ";"
		| Class<true>
		| Enum<true>
		| GenericStatement
		| Block<false>
		| ";"
		.
GenericStatement =
	(ident | string | this | "throw" | ParExpr | Instantiation)
		{string | char
			| ArrowExpression<false, false>
			| SwitchStatement
			| Instantiation
			| ANY
		} ";".
BlockOrSingleStatement =
		Block<false>
		| (. state.checkSingleStatement(false, false, false); .) Statement (. state.leaveSingleStatement(); .)
		.
SwitchStatement = 						(. boolean inAssignment = state.isAssignment(); .)
			"switch" ParExpr "{" {SwitchCase<inAssignment>}
			"}"
			.
SwitchCase<boolean inAssignment> =
	("case" | "default") {ANY}
	(ArrowExpression<true, inAssignment>
		| ":" {"case" {ANY} ":"}	(. state.checkSingleStatement(false, true, false); .)
			{Statement}							(. state.leaveSingleStatement(); .)
	)
	.
ParExpr = "(" {ParExpr | ANY} ")".
BraceExpr = "{" {BraceExpr | ANY} "}".
BracketExpr = "[" {ANY} "]".
AngleBracketExpr = "<" {AngleBracketExpr | ANY} ">".
ArrowExpression<boolean inSwitch, boolean inAssignment> =
		"->" (Block<false> | SSArrowBody<inSwitch, inAssignment>)
	.
SSArrowBody<boolean inSwitch, boolean inAssignment> =
 																		(. state.checkSingleStatement(inAssignment, inSwitch, true); .)
				(ANY | ParExpr | string | char | ident | "throw" (. state.registerThrow(); .))
				{ANY | ParExpr}
				(")" | ";")									(. state.leaveSingleStatement(); .)
				.
Instantiation = "new" ident {["."] ident} (ArrayInitRest | ClassInitRest).
ArrayInitRest = BracketExpr [BraceExpr].
ClassInitRest = [AngleBracketExpr] ParExpr [ClassExtension].
ClassExtension = "{" (. state.enterClass(true, false); .) ClassBody (. state.leaveClass();.).
Block<boolean isMethod> = 					(. state.enterBlock(isMethod); .)
				"{" {Statement} "}"					(. state.leaveBlock(isMethod); .)
			.

END Instrumenter.
