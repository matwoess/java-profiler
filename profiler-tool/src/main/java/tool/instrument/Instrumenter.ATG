COMPILER Instrumenter
    ParserState state = new ParserState(this);

CHARACTERS
    cr = '\r'.
    lf = '\n'.
    tab = '\t'.
    letter = 'a'..'z' + 'A'..'Z' + '_'.
    digit  = '0'..'9'.
    bslash = '\\'.
    quote = '"'.
    apostrophe = '\''.
    noApostrophe = ANY - apostrophe - bslash - cr - lf.
    noQuote = ANY - quote.
    noQuoteNoBSlash = ANY - quote - bslash.
    escapableChar = 'b'+ 's' + 't' + 'n' + 'f' + 'r' + quote + apostrophe + bslash.
    hexDigit = digit + 'a'..'f' + 'A'..'F'.
    zeroToThree = "0123".
    octalDigit = "01234567".
TOKENS
    ident = letter {letter | digit}.
    char =
        apostrophe (
            noApostrophe
            | bslash (
                escapableChar
                | 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
                | (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
            )
        ) apostrophe.
    string =
        quote (
            quote quote lf  // multi-line "text block" string
                {   noQuote
                    | quote noQuote
                    | quote quote noQuote
                    | [quote] [quote] bslash quote
                }
                quote quote quote
            | {
                (   noQuoteNoBSlash
                    | bslash (
                        escapableChar
                        | 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
                        | (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
                    )
                )
            }
            quote
        ).
    // .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
    class  = "class".
    this   = "this".
    newRef = "::new".  // exclude from being interpreted as Instantiation NTS

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE tab + cr + lf

PRODUCTIONS

Instrumenter =
    [PackageDecl]
    {   AnnotationType
        | Annotation
        | IF(state.classDefWithNoLeadingDot()) Class<false>
        | Enum<false>
        | ANY
    }
.
PackageDecl = "package"     (. ArrayList<String> packageName = new ArrayList<>(); .)
    ident                   (. packageName.add(t.val); .)
    {'.' ident              (. packageName.add(t.val); .)
    }
    ";"                     (. state.setPackageName(packageName); .)
.
AnnotationType = "@interface" ident BraceExpr.
Annotation = "@" ident {"." ident} [ParExpr].
Class<boolean local> =
    (class | "interface" | ident/*"record"*/)    (. state.enterClass(false, local); .)
    ident {ANY} "{"
    ClassBody                           (. state.leaveClass(); .)
.
Enum<boolean local> =
    "enum"                              (. state.enterClass(false, local); .)
    ident {ANY} "{"
    { [Annotation] ident [ParExpr] ["{" ClassBody] [","]}
    (   ";" ClassBody                   // class body can follow only after a ";"
        | "}"
    )                                   (. state.leaveClass(); .)
.
ClassBody =
    {   Enum<false>
        | IF(state.classDefWithNoLeadingDot()) Class<false>
        | "=" (BraceExpr | {ANY} Statement)
        | IF(state.identAndLPar()) MethodDecl
        | IF(state.classNameAndLBrace()) MethodDecl  // compact record constructor
        | IF(state.staticAndLBrace()) StaticBlock
        | AnnotationType | Annotation
        | ANY
    }
    "}"
.
StaticBlock = "static" Block<STATIC>.
MethodDecl =
    ident                   (. state.enterMethod(); .)
    {ANY}
    (   ";"                 (. state.leaveMethod(); .)
        | Block<METHOD>
    )
.
Statement =
    "if" ParExpr BlockOrSingleStatement<BLOCK> ["else" BlockOrSingleStatement<BLOCK>]
    | SwitchStatement
    | "while" ParExpr BlockOrSingleStatement<LOOP>
    | "do" BlockOrSingleStatement<LOOP> "while" ParExpr ";"
    | "for" ParExpr BlockOrSingleStatement<LOOP>
    | "try" [ParExpr] Block<BLOCK> {"catch" ParExpr Block<BLOCK>} ["finally" Block<BLOCK>]
    | ("break" | "continue") (. state.registerJumpStatement(); .) {ANY} ";"
    | ("return" | "yield") (. state.registerJumpStatement(); .) (SwitchStatement | {ANY | ParExpr | BraceExpr}) ";"
    | "throw" (. state.registerJumpStatement(); .) {ANY} ";"
    | IF(state.isLabel()) ident ":"
    | Annotation
    | "super" (ParExpr ";" (. state.markEndOfSuperCall(); .) | "." {ANY} ";")
    | IF(state.thisAndLPar()) this ParExpr ";" (. state.markEndOfSuperCall(); .)
    | ("++" | "--") ["("] ident [")"] ";"
    | "synchronized" ParExpr Block<BLOCK>
    | IF(state.classDefWithNoLeadingDot()) Class<true>
    | Enum<true>
    | GenericStatement
    | Block<BLOCK>
    | ";"
.
GenericStatement =
    (ident | string | this | ParExpr | Instantiation)
    {   string | char
        | ArrowExpression<false, false>
        | SwitchStatement
        | Instantiation
        | ANY
    }
    ";"
.
BlockOrSingleStatement<BlockType blockType> =
    Block<blockType>
    | (. state.enterSingleStatementBlock(blockType); .) Statement (. state.leaveSingleStatement(blockType); .)
.
SwitchStatement =                       (. boolean inAssignment = state.isAssignment(); .)
    "switch" ParExpr "{" {SwitchCase<inAssignment>}
    "}"
.
SwitchCase<boolean inAssignment> =
    ("case" | "default") {ANY}
    (   ArrowExpression<true, inAssignment>
        | ":" {"case" {ANY} ":"}        (. state.enterBlock(inAssignment ? SWITCH_EXPR_CASE : SWITCH_CASE); .)
          {Statement}                   (. state.leaveBlock(inAssignment ? SWITCH_EXPR_CASE : SWITCH_CASE); .)
    )
.
ParExpr = "(" {ParExpr | ANY} ")".
BraceExpr = "{" {BraceExpr | ANY} "}".
BracketExpr = "[" {ANY} "]".
AngleBracketExpr = "<" {AngleBracketExpr | ANY} ">".
ArrowExpression<boolean inSwitch, boolean inAssignment> =
    "->" (Block<inSwitch ? inAssignment ? SWITCH_EXPR_CASE : SWITCH_CASE : LAMBDA> | SSArrowBody<inSwitch, inAssignment>)
.
SSArrowBody<boolean inSwitch, boolean inAssignment> =   (. BlockType blockType = state.enterSSArrowBlock(inSwitch, inAssignment); .)
    (   string | char
        | ParExpr
        | ident
        | "throw"                                       (. state.registerJumpStatement(); .)
        | ANY
    )                                                   // exclude ")" or ";" in lambda blocks with no "Get" for ";"
    {ANY | ParExpr}                                     (. if (!inSwitch) { state.leaveSingleStatement(blockType); return; } .)
    (")" | ";")                                         (. state.leaveSingleStatement(blockType); .)
.
Instantiation = "new" ident {["."] ident} [AngleBracketExpr] (ArrayInitRest | ClassInitRest).
ArrayInitRest = BracketExpr [BraceExpr].
ClassInitRest = ParExpr [ClassExtension].
ClassExtension =
    "{"                                     (. state.enterClass(true, false); .)
    ClassBody                               (. state.leaveClass();.)
.
Block<BlockType blockType> =                (. state.enterBlock(blockType); .)
    "{" {Statement}                         (. state.leaveBlock(blockType); .)
    "}"
.

END Instrumenter.
