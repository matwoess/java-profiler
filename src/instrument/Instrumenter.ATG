COMPILER Instrumenter
	ParserState state = new ParserState(this);

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	tab = '\t'.
	letter = 'a'..'z' + 'A'..'Z' + '_'.
	digit  = '0'..'9'.
	bslash = '\\'.
	quote = '"'.
	apostrophe = '\''.
	noApostrophe = ANY - apostrophe- bslash - cr - lf.
 	noQuote = ANY - quote - bslash - cr - lf.
	escapableChar = 'b'+ 's' + 't' + 'n' + 'f' + 'r' + quote + apostrophe + bslash.
	hexDigit = digit + 'a'..'f' + 'A'..'F'.
	zeroToThree = "0123".
	octalDigit = "01234567".
TOKENS
	ident  = letter {letter | digit}.
	char =
		apostrophe (
			bslash (
				escapableChar
				| 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
				| (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
			)
			| noApostrophe
		) apostrophe.
	string =
		quote {(
			bslash (
				escapableChar
				| 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
				| (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
			)
			| noQuote
		)} quote.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	class      = "class".
	interface  = "interface".
	enum       = "enum".
	lpar       = '('.
	rpar       = ')'.
	lbrac      = '['.
	lbrace     = '{'.
	colon      = ':'.
	static     = "static".
	if         = "if".
	else       = "else".
	public     = "public".
	void       = "void".
	main       = "main".
	equals     = "=".
	new        = "new".
	this       = "this".
	return     = "return".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE tab + cr + lf

PRODUCTIONS

Instrumenter = [PackageDecl] { Annotation | Class | Enum | ANY }.
PackageDecl = "package" (. ArrayList<String> packageName = new ArrayList<>(); .)
		ident 							(. packageName.add(t.val); .)
		{'.' ident 					(. packageName.add(t.val); .)
		}
		";" 								(. state.setPackageName(packageName); .)
		.
Annotation = "@" ident [ParExpr].
Class =
		("class" | "interface")	(. state.enterClass(); .)
		ident {ANY} "{"
		ClassBody								(. state.leaveClass(); .)
	.
Enum =
	"enum"										(. state.enterClass(); .)
	ident {ANY} "{"
	{[","] ident [ParExpr]}
	(";" ClassBody						// class body can follow only after a ";"
		| "}") 									(. state.leaveClass(); .)
	.
ClassBody =
	{ Enum | Class
		| "=" (BraceExpr | {ANY} Statement)
		| IF(state.isEntryPoint()) MainMethod
		| IF(state.identAndLPar()) MethodDecl
		| IF(state.staticAndLBrace()) StaticBlock
		| Annotation
		| ANY
	}
	"}"
.
MainMethod =
		[public] static void main	(. state.enterMainMethod(); .)
		ParExpr ["throws" {ANY}] Block<true>
		.
StaticBlock =	static Block<false>.
MethodDecl  = ident 					(. state.enterMethod(); .)
						ParExpr ["throws" {ANY}] (";" | Block<true>).
Statement =
		if ParExpr BlockOrSingleStatement [else BlockOrSingleStatement]
		| SwitchStatement
		| "while" ParExpr BlockOrSingleStatement
 		| "do" BlockOrSingleStatement "while" ParExpr ";"
		| "for" ParExpr BlockOrSingleStatement
		| "try" [ParExpr] Block<false> {"catch" ParExpr Block<false>} ["finally" Block<false>]
		| ("break" | "continue") {ANY} ";"
		| "return" (SwitchStatement | {ANY}) ";"
		| IF(state.isLabel()) ident colon
		| Annotation
		| "super" (ParExpr ";" (. state.markEndOfSuperCall(); .) | "." {ANY} ";")
		| IF(state.thisAndLPar()) this ParExpr ";" (. state.markEndOfSuperCall(); .)
		| ("++" | "--") ["("] ident [")"] ";"
		| "throw" ["new"] ident [ParExpr] ";" // TODO: investigate if needed
		| (ParExpr | Instantiation | ident | string | this)
				{string | char
					| ArrowExpression<false, false>
					| SwitchStatement
					| Instantiation
					| ANY
				} ";"
		| Block<false>
		| ";"
		.
BlockOrSingleStatement =
		Block<false>
		| (. state.checkSingleStatement(false, false, false); .) Statement (. state.leaveSingleStatement(); .)
		.
SwitchStatement = 						(. boolean inAssignment = state.isAssignment(); .)
			"switch" ParExpr "{" {SwitchCase<inAssignment>}
			"}"
			.
SwitchCase<boolean inAssignment> =
	("case" | "default") {ANY}
	(ArrowExpression<true, inAssignment>
		| ":"											(. state.checkSingleStatement(false, true, false); .)
			{Statement}							(. state.leaveSingleStatement(); .)
	)
	.
ParExpr = "(" {ParExpr | ANY} ")".
BraceExpr = "{" {BraceExpr | ANY} "}".
BracketExpr = "[" {ANY} "]".
AngleBracketExpr = "<" {AngleBracketExpr | ANY} ">".
ArrowExpression<boolean inSwitch, boolean inAssignment> =
		"->" (Block<false> | SSArrowBody<inSwitch, inAssignment>)
	.
SSArrowBody<boolean inSwitch, boolean inAssignment> =
 																		(. state.checkSingleStatement(inAssignment, inSwitch, true); .)
				(ANY | ParExpr | string | char | ident | "throw" (. state.registerThrow(); .))
				{ANY | ParExpr}
				(")" | ";")									(. state.leaveSingleStatement(); .)
				.
Instantiation = "new" ident {["."] ident}
		(BracketExpr [BraceExpr] // array initializer
			| [AngleBracketExpr] ParExpr ["{" (. state.enterClass(true); .) ClassBody (. state.leaveClass();.)]
		) ";"
		.
Block<boolean isMethod> = 					(. state.enterBlock(isMethod); .)
				"{" {Statement} "}"					(. state.leaveBlock(isMethod); .)
			.

END Instrumenter.
