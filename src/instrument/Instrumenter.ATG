COMPILER Instrumenter

	int beginOfImports = 0;
	List<Class> allClasses = new ArrayList<>();
	Stack<Class> classStack = new Stack<>();
	List<Block> allBlocks = new ArrayList<>();
	Stack<Block> blockStack = new Stack<>();
	Class curClass = null;
	Method curMeth = null;
	Block curBlock = null;

	void markBeginOfImports() {
		beginOfImports = t.charPos + t.val.length();
	}

	void enterClass() {
		if (curClass != null) {
			classStack.push(curClass);
		}
		String className = (!classStack.isEmpty()) ? classStack.peek().name + "." + t.val : t.val;
		curClass = new Class(className);
		allClasses.add(curClass);
		System.out.printf("entering class <%s>\n", curClass.name);

	}

	void leaveClass() {
		System.out.printf("left class <%s>\n", curClass.name);
		if (classStack.empty()) {
			curClass = null;
		} else {
			curClass = classStack.pop();
		}
	}

	void enterMethod() {
		assert curClass != null;
		curMeth = new Method(t.val);
		curClass.methods.add(curMeth);
		System.out.println("found method declaration of: " + curMeth.name);
	}

	void enterMainMethod() {
		enterMethod();
		curMeth.isMain = true;
		curClass.isMain = true;
		System.out.println("method is main entry point.");
	}

	void leaveMethod() {
		curBlock.isMethodBlock = true;
		System.out.println("left method: " + curMeth.name);
		curMeth = null;
	}

	void enterStaticBlock() {
		curMeth = new Method(t.val);
		curClass.methods.add(curMeth);
		System.out.println("found static block");
  }

	void leaveStaticBlock() {
		System.out.println("left static block");
		curMeth = null;
	}

	void enterBlock(boolean missingBraces) {
		assert curMeth != null;
		if (curBlock != null) {
			blockStack.push(curBlock);
		}
		curBlock = new Block();
		curBlock.clazz = curClass;
		curBlock.method = curMeth;
		curBlock.beg = t.line;
		curBlock.begPos = t.charPos + t.val.length();
		curBlock.insertBraces = missingBraces;
		allBlocks.add(curBlock);
		curMeth.blocks.add(curBlock);
		System.out.printf("entering block %s\n", curBlock);
	}

	void enterBlock() {
		enterBlock(false); // no missing braces
	}

	void leaveBlock() {
		curBlock.end = t.line;
		curBlock.endPos = t.charPos + t.val.length();
		System.out.printf("left block %s\n", curBlock);
		if (blockStack.empty()) {
			if ("static".equals(curMeth.name)) {
				leaveStaticBlock();
			} else {
				leaveMethod();
			}
			curBlock = null;
		} else {
			curBlock = blockStack.pop();
		}
	}

	void checkInsertLBrace() {
		if (t.kind == _else && la.kind == _if) {
			System.out.println("else if found. no block.");
			return;
		}
		if (la.kind != _lbrace) {
			System.out.println("found single statement block.");
			enterBlock(true);
		}
	}

	void checkInsertRBrace() {
		if (curBlock.insertBraces) {
			System.out.println("left single statement block.");
			leaveBlock();
		}
	}

	boolean identAndLPar() {
		return la.kind == _ident && scanner.Peek().kind == _lpar;
	}

	boolean staticAndLBrace() {
		return la.kind == _static && scanner.Peek().kind == _lbrace;
	}

	boolean isLabel() {
	  return la.kind == _ident && scanner.Peek().kind == _colon;
	}

	boolean isEntryPoint() {
		return la.kind == _public
				&& scanner.Peek().kind == _static
				&& scanner.Peek().kind == _void
				&& scanner.Peek().kind == _main;
	}

	boolean isInterfaceEntryPoint() {
		// the "public" can be omitted in interfaces (implied)
		return la.kind == _static
				&& scanner.Peek().kind == _void
				&& scanner.Peek().kind == _main;
	}

CHARACTERS
	letter = 'a' .. 'z' + 'A'..'Z'.
	digit  = '0'..'9'.
TOKENS
	ident  = letter {letter | digit | '_'}.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	lpar   = '('.
	lbrace = '{'.
	colon  = ':'.
	static = "static".
	if     = "if".
	else   = "else".
	public = "public".
	void   = "void".
	main   = "main".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE "\t\n\r"

PRODUCTIONS

Instrumenter = [PackageDecl] { Class | Interface | Enum | ANY }.
PackageDecl = "package" {ANY} ";" (. markBeginOfImports(); .)
						.
Class =
			"class" ident						(. enterClass(); .)
			{ANY} "{"
			{ Class | Interface | Enum
				| "=" {ANY} ";"  // against class member with initializers
				| IF(isEntryPoint()) MainMethod
				| IF(identAndLPar()) MethodDecl
				| IF(staticAndLBrace()) StaticBlock
				| ANY
			}
			"}"											(. leaveClass(); .)
		.
Interface =
					"interface" ident		(. enterClass(); .)
					{ANY} "{"
					{ Interface | Class | Enum
						| "=" {ANY} ";"  // against class member with initializers
						| IF(isInterfaceEntryPoint()) MainMethod
						| IF(identAndLPar()) MethodDecl
						| ANY
					}
					"}"									(. leaveClass(); .)
					.
Enum =
			"enum" ident						(. enterClass(); .)
			{ANY} "{"
			{[","] ident [BracketExpr]}
			[";"  // class body can follow only after a ";"
				{ Enum | Class | Interface
					| "=" {ANY} ";"  // against class member with initializers
					| IF(isEntryPoint()) MainMethod
					| IF(identAndLPar()) MethodDecl
					| IF(staticAndLBrace()) StaticBlock
					| ANY
				}
			]
			"}"											(. leaveClass(); .)
		.
MainMethod =
		[public] static void main	(. enterMainMethod(); .)
		BracketExpr Block
		.
StaticBlock =	static 					(. enterStaticBlock(); .)
						Block.
MethodDecl  = ident 					(. enterMethod(); .)
						BracketExpr (";" | Block).
Statement =
		if BracketExpr BlockOrSingleStatement [else BlockOrSingleStatement]
		| SwitchStatement
		| "while" BracketExpr BlockOrSingleStatement
 		| "do" BlockOrSingleStatement "while" BracketExpr ";"
		| "for" BracketExpr BlockOrSingleStatement
		| "try" Block {"catch" BracketExpr Block} ["finally" Block]
		| ("break" | "return" | "continue") {ANY} ";"
		| IF(isLabel()) ident colon
		| (ident | QuotedText) {ANY | QuotedText | LambdaExpression} ";"
		| Block
		| ";"
		.
BlockOrSingleStatement =
		Block
		| (. checkInsertLBrace(); .) Statement (. checkInsertRBrace(); .)
		.
SwitchStatement =
			"switch" BracketExpr "{"
			{"case" {ANY}
					(LambdaExpression
						| ":"							(. checkInsertLBrace(); .)
						{Statement}				(. checkInsertRBrace(); .)
					)
				}
			["default"
					(LambdaExpression
						|":"							(. checkInsertLBrace(); .)
						{Statement}				(. checkInsertRBrace(); .)
					)
				]
			"}"
			.
QuotedText = '"' {ANY} '"'.
BracketExpr = "(" {BracketExpr | ANY} ")".
LambdaExpression = "->" (Block | LambdaBody).
LambdaBody = 									(. checkInsertLBrace(); .)
				(ANY | BracketExpr | QuotedText | ident)
				{ANY | BracketExpr}		(. checkInsertRBrace(); .)
				(")" | ";")
				.
Block = "{"										(. enterBlock(); .)
				{Statement}
				"}"										(. leaveBlock(); .)
			.

END Instrumenter.
