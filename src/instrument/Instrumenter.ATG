COMPILER Instrumenter

	List<Class> classes = new ArrayList<>();
	Stack<String> classNameStack = new Stack<>();
	List<Block> allBlocks = new ArrayList<>();
	Stack<Block> blockStack = new Stack<>();
	Class curClass = null;
	Method curMeth = null;
	Block curBlock = null;
	Token[] prevTokens = new Token[4];


	public static class Class {
		String name;
		boolean isMain;
		List<Method> methods = new ArrayList<>();
		public Class(String name) {this.name = name;}
		public Class(String name, boolean isMain) {
			this.name = name;
			this.isMain = isMain;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Class method = (Class) o;
			if (isMain != method.isMain) return false;
			return name.equals(method.name);
		}

		@Override
		public int hashCode() {
			int result = name.hashCode();
			result = 31 * result + (isMain ? 1 : 0);
			return result;
		}
	}

	public static class Method {
		String name;
		boolean isMain;
		List<Block> blocks = new ArrayList<>();
		public Method(String name) {this.name = name;}
		public Method(String name, boolean isMain) {
			this.name = name;
			this.isMain = isMain;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Method method = (Method) o;
			if (isMain != method.isMain) return false;
			return name.equals(method.name);
		}

		@Override
		public int hashCode() {
			int result = name.hashCode();
			result = 31 * result + (isMain ? 1 : 0);
			return result;
		}
	}

	public static class Block {
		Class clazz;
		Method method;
		int beg, end;
		int begPos, endPos;
		boolean isMethodBlock;
		boolean insertBraces;

		public String toString() {
			return String.format("%s%s: {%d[%s]-%s[%s]}%s",
				clazz.name,
				method != null ? ("." + method.name) : "",
				beg,
				begPos,
				end != 0 ? end : "?",
				endPos != 0 ? endPos : "?",
				isMethodBlock ? " m" : insertBraces ? " ins" : ""
			);
	  }

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Block block = (Block) o;
			if (beg != block.beg) return false;
			if (end != block.end) return false;
			if (begPos != block.begPos) return false;
			if (endPos != block.endPos) return false;
			if (isMethodBlock != block.isMethodBlock) return false;
			if (insertBraces != block.insertBraces) return false;
			if (!clazz.equals(block.clazz)) return false;
			return method.equals(block.method);
		}

		@Override
		public int hashCode() {
			int result = clazz.hashCode();
			result = 31 * result + method.hashCode();
			result = 31 * result + beg;
			result = 31 * result + end;
			result = 31 * result + begPos;
			result = 31 * result + endPos;
			result = 31 * result + (isMethodBlock ? 1 : 0);
			result = 31 * result + (insertBraces ? 1 : 0);
			return result;
		}
	}

	void enterClass() {
		classNameStack.push(t.val);
		curClass = new Class(String.join(".", classNameStack));
		classes.add(curClass);
		System.out.printf("entering class <%s>\n", curClass.name);

	}

	void leaveClass() {
		classNameStack.pop();
		System.out.printf("left class <%s>\n", curClass.name);
	}

	void enterMethod() {
		assert curClass != null;
		curMeth = new Method(t.val);
		curClass.methods.add(curMeth);
		System.out.println("found method declaration of: " + curMeth.name);
		if ("main".equals(prevTokens[0].val) && "void".equals(prevTokens[1].val) && "static".equals(prevTokens[2].val) && "public".equals(prevTokens[3].val)) {
			curMeth.isMain = true;
			curClass.isMain = true;
			System.out.println("method is main entry point.");
		}
	}

	void leaveMethod() {
		curBlock.isMethodBlock = true;
		System.out.println("left method: " + curMeth.name);
		curMeth = null;
	}

	void enterStaticBlock() {
		curMeth = new Method(t.val);
		curClass.methods.add(curMeth);
		System.out.println("found static block");
  }

	void leaveStaticBlock() {
		System.out.println("left static block");
		curMeth = null;
	}

	void enterBlock(boolean missingBraces) {
		assert curMeth != null;
		if (curBlock != null) {
			blockStack.push(curBlock);
		}
		curBlock = new Block();
		curBlock.clazz = curClass;
		curBlock.method = curMeth;
		curBlock.beg = t.line;
		curBlock.begPos = t.charPos + t.val.length();
		curBlock.insertBraces = missingBraces;
		allBlocks.add(curBlock);
		curMeth.blocks.add(curBlock);
		System.out.printf("entering block %s\n", curBlock);
	}

	void enterBlock() {
		enterBlock(false); // no missing braces
	}

	void leaveBlock() {
		curBlock.end = t.line;
		curBlock.endPos = t.charPos + t.val.length();
		System.out.printf("left block %s\n", curBlock);
		if (blockStack.empty()) {
			if ("static".equals(curMeth.name)) {
				leaveStaticBlock();
			} else {
				leaveMethod();
			}
			curBlock = null;
		} else {
			curBlock = blockStack.pop();
		}
	}

	void checkInsertLBrace() {
		if (t.kind == _else && la.kind == _if) {
			System.out.println("else if found. no block.");
			return;
		}
		if (la.kind != _lbrace) {
			System.out.println("found single statement block.");
			enterBlock(true);
		}
	}

	void checkInsertRBrace() {
		if (curBlock.insertBraces) {
			System.out.println("left single statement block.");
			leaveBlock();
		}
	}

	boolean identAndLPar() {
		return t.kind == _ident && la.kind == _lpar;
	}

	boolean staticAndLBrace() {
		return t.kind == _static && la.kind == _lbrace;
	}

	void logToken() {
		if (t == prevTokens[0]) { // sometimes same token appears twice
			return;
		}
		prevTokens[3] = prevTokens[2];
		prevTokens[2] = prevTokens[1];
		prevTokens[1] = prevTokens[0];
		prevTokens[0] = t;
	}

CHARACTERS
	letter = 'a' .. 'z' + 'A'..'Z'.
	digit  = '0'..'9'.
TOKENS
	ident  = letter {letter | digit | '_'}.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	lpar   = '('.
	lbrace = '{'.
	static = "static".
	if     = "if".
	else   = "else".
IGNORE "\t\n\r"

PRODUCTIONS

Instrumenter = { {ANY} Class }.
Class =
			"class" ident						(. enterClass(); .)
			{ANY} "{"
			{ Class
				| "abstract" ident {ANY} ";"
				| IF(identAndLPar()) MethodDecl
				| IF(staticAndLBrace()) StaticBlock
				| ANY									(. logToken(); .)
			}
			"}"											(. leaveClass(); .)
		.
StaticBlock =									(. enterStaticBlock(); .)
						Block.
MethodDecl  =									(. enterMethod(); .)
						BracketExpr Block.
Statement =
		if BracketExpr						(. checkInsertLBrace(); .)
			Statement								(. checkInsertRBrace(); .)
			[else										(. checkInsertLBrace(); .)
				Statement							(. checkInsertRBrace(); .)
			]
		| "switch" BracketExpr "{"
			{"case" {ANY} ":" {Statement}}
			["default" ":" {Statement}]
			"}"
		| "while" BracketExpr			(. checkInsertLBrace(); .)
			Statement								(. checkInsertRBrace(); .)
 		| "do"										(. checkInsertLBrace(); .)
			Statement 							(. checkInsertRBrace(); .)
			"while" BracketExpr ";"
		| "for" BracketExpr				(. checkInsertLBrace(); .)
			Statement								(. checkInsertRBrace(); .)
		| "try" Block {"catch" BracketExpr Block} ["finally" Block]
		| ("break" | "return" | "continue") {ANY} ";"
		| ident ({ANY | QuotedText | "->" Statement} ";" | ":")
		| Block
		| ";" .
QuotedText = '"' {ANY} '"'.
BracketExpr = "(" {BracketExpr | ANY} ")".
Block = "{"										(. enterBlock(); .)
				{Statement}
				"}"										(. leaveBlock(); .)
			.

END Instrumenter.
