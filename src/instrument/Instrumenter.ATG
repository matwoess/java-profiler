COMPILER Instrumenter
	ParserState state = new ParserState(this);

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	tab = '\t'.
	letter = 'a' .. 'z' + 'A'..'Z' + '_'.
	digit  = '0'..'9'.
	escCh = '\\'.
	quote = '"'.
	apostrophe = '\''.
 	noQuote = ANY - quote - cr - lf.
	noApostrophe = ANY - apostrophe - cr - lf.
TOKENS
	ident  = letter {letter | digit}.
	char = apostrophe [escCh] noApostrophe apostrophe.
	string = quote { ( escCh escCh | [escCh] noQuote) } quote.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	class      = "class".
	interface  = "interface".
	enum       = "enum".
	lpar       = '('.
	rpar       = ')'.
	lbrace     = '{'.
	colon      = ':'.
	static     = "static".
	if         = "if".
	else       = "else".
	public     = "public".
	void       = "void".
	main       = "main".
	equals     = "=".
	new        = "new".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE tab + cr + lf

PRODUCTIONS

Instrumenter = [PackageDecl] { Annotation | Class | Enum | ANY }.
PackageDecl = "package" {ANY} ";" (. state.markBeginOfImports(); .)
						.
Annotation = "@" ident [ParExpr].
Class =
		("class" | "interface")	(. state.enterClass(); .)
		ident {ANY} "{"
		ClassBody								(. state.leaveClass(); .)
	.
Enum =
	"enum"										(. state.enterClass(); .)
	ident {ANY} "{"
	{[","] ident [ParExpr]}
	([";" ClassBody] // class body can follow only after a ";"
		| "}") 									(. state.leaveClass(); .)
	.
ClassBody =
	{ Enum | Class
		| "=" (BraceExpr | {ANY} Statement)
		| IF(state.isEntryPoint()) MainMethod
		| IF(state.identAndLPar()) MethodDecl
		| IF(state.staticAndLBrace()) StaticBlock
		| Annotation
		| ANY
	}
	"}"
.
MainMethod =
		[public] static void main	(. state.enterMainMethod(); .)
		ParExpr ["throws" {ANY}] Block
		.
StaticBlock =	static Block.
MethodDecl  = ident 					(. state.enterMethod(); .)
						ParExpr ["throws" {ANY}] (";" | Block).
Statement =
		if ParExpr BlockOrSingleStatement [else BlockOrSingleStatement]
		| SwitchStatement
		| "while" ParExpr BlockOrSingleStatement
 		| "do" BlockOrSingleStatement "while" ParExpr ";"
		| "for" ParExpr BlockOrSingleStatement
		| "try" [ParExpr] Block {"catch" ParExpr Block} ["finally" Block]
		| ("break" | "return" | "continue") {ANY} ";"
		| IF(state.isLabel()) ident colon
		| Annotation
		| (new | ident | string | ParExpr)
				{string | char
					| ArrowExpression<false, false>
					| SwitchStatement
					| IF(state.isAnonymousClass()) AnonymousClass
					| ANY
				} ";"
		| Block
		| ";"
		.
BlockOrSingleStatement =
		Block
		| (. state.checkSingleStatement(false, false, false); .) Statement (. state.leaveSingleStatement(); .)
		.
SwitchStatement = 						(. boolean inAssignment = state.isAssignment(); .)
			"switch" ParExpr "{" {SwitchCase<inAssignment>}
			"}"
			.
SwitchCase<boolean inAssignment> =
	("case" | "default") {ANY}
	(ArrowExpression<true, inAssignment>
		| ":"											(. state.checkSingleStatement(false, true, false); .)
		{Statement}								(. state.leaveSingleStatement(); .)
	)
	.
ParExpr = "(" {ParExpr | ANY} ")".
BraceExpr = "{" {BraceExpr | ANY} "}".
ArrowExpression<boolean inSwitch, boolean inAssignment> =
		"->" (Block | SSArrowBody<inSwitch, inAssignment>)
	.
SSArrowBody<boolean inSwitch, boolean inAssignment> =
 																		(. state.checkSingleStatement(inAssignment, inSwitch, true); .)
				(ANY | ParExpr | string | char | ident)
				{ANY | ParExpr}
				(")" | ";")									(. state.leaveSingleStatement(); .)
				.
AnonymousClass = "(" "new" ident {ANY} ParExpr "{" ClassBody ")".
Block = 														(. state.enterBlock(); .)
				"{" {Statement} "}"					(. state.leaveBlock(); .)
			.

END Instrumenter.
