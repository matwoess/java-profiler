COMPILER Instrumenter
	ParserState state = new ParserState(this);

CHARACTERS
	letter = 'a' .. 'z' + 'A'..'Z'.
	digit  = '0'..'9'.
	escCh = '\\'.
	quote = '"'.
	apostrophe = '\''.
 	noQuote = ANY - quote.
	noApostrophe = ANY - apostrophe.
TOKENS
	ident  = letter {letter | digit | '_'}.
	char = apostrophe (escCh apostrophe | [escCh] noApostrophe) apostrophe.
	string = quote { (escCh quote | [escCh] noQuote) } quote.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	class      = "class".
	interface  = "interface".
	enum       = "enum".
	lpar       = '('.
	lbrace     = '{'.
	colon      = ':'.
	static     = "static".
	if         = "if".
	else       = "else".
	public     = "public".
	void       = "void".
	main       = "main".
	equals     = "=".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE "\t\n\r"

PRODUCTIONS

Instrumenter = [PackageDecl] { Class | Enum | ANY }.
PackageDecl = "package" {ANY} ";" (. state.markBeginOfImports(); .)
						.
Class =
			("class" | "interface")	(. state.enterClass(); .)
			ident {ANY} "{"
			{ Class | Enum
				| "=" {ANY} ";"  // against class member with initializers
				| IF(state.isEntryPoint()) MainMethod
				| IF(state.identAndLPar()) MethodDecl
				| IF(state.staticAndLBrace()) StaticBlock
				| ANY
			}
			"}"											(. state.leaveClass(); .)
		.
Enum =
			"enum"									(. state.enterClass(); .)
			ident {ANY} "{"
			{[","] ident [ParExpr]}
			[";"  // class body can follow only after a ";"
				{ Enum | Class
					| "=" {ANY} ";"  // against class member with initializers
					| IF(state.isEntryPoint()) MainMethod
					| IF(state.identAndLPar()) MethodDecl
					| IF(state.staticAndLBrace()) StaticBlock
					| ANY
				}
			]
			"}"											(. state.leaveClass(); .)
		.
MainMethod =
		[public] static void main	(. state.enterMainMethod(); .)
		ParExpr Block
		.
StaticBlock =	static Block.
MethodDecl  = ident 					(. state.enterMethod(); .)
						ParExpr (";" | Block).
Statement =
		if ParExpr BlockOrSingleStatement [else BlockOrSingleStatement]
		| SwitchStatement
		| "while" ParExpr BlockOrSingleStatement
 		| "do" BlockOrSingleStatement "while" ParExpr ";"
		| "for" ParExpr BlockOrSingleStatement
		| "try" Block {"catch" ParExpr Block} ["finally" Block]
		| ("break" | "return" | "continue") {ANY} ";"
		| IF(state.isLabel()) ident colon
		| (ident | string) {ANY | string | char | LambdaExpression | SwitchStatement} ";"
		| Block
		| ";"
		.
BlockOrSingleStatement =
		Block
		| (. state.checkInsertLBrace(); .) Statement (. state.checkInsertRBrace(); .)
		.
SwitchStatement = 						(. state.checkAssignment(); .)
			"switch" ParExpr "{" {SwitchCase}
			"}"											(. state.leaveAssignment(); .)
			.
SwitchCase =
	("case" | "default") {ANY}
	(LambdaExpression
		| ":"							(. state.checkInsertLBrace(); .)
		{Statement}				(. state.checkInsertRBrace(); .)
	)
	.
ParExpr = "(" {ParExpr | ANY} ")".
LambdaExpression = "->"				(. state.enterLambda(); .)
		(Block | SingleStatementLambdaBody) (. state.leaveLambda(); .)
	.
SingleStatementLambdaBody = 	(. state.checkInsertLBrace(); .)
				(ANY | ParExpr | string | char | ident)
				{ANY | ParExpr}
				(")" | ";")						(. state.checkInsertRBrace(); .)
				.
Block = 											(. state.enterBlock(); .)
				"{" {Statement} "}"		(. state.leaveBlock(); .)
			.

END Instrumenter.
