COMPILER Instrumenter
	ParserState state = new ParserState(this);

CHARACTERS
	cr = '\r'.
	lf = '\n'.
	tab = '\t'.
	letter = 'a'..'z' + 'A'..'Z' + '_'.
	digit  = '0'..'9'.
	bslash = '\\'.
	quote = '"'.
	apostrophe = '\''.
	noApostrophe = ANY - apostrophe- bslash - cr - lf.
 	noQuote = ANY - quote - bslash - cr - lf.
	escapableChar = 'b'+ 's' + 't' + 'n' + 'f' + 'r' + quote + apostrophe + bslash.
	hexDigit = digit + 'a'..'f' + 'A'..'F'.
	zeroToThree = "0123".
	octalDigit = "01234567".
TOKENS
	ident  = letter {letter | digit}.
	char =
		apostrophe (
			bslash (
				escapableChar
				| 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
				| (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
			)
			| noApostrophe
		) apostrophe.
	string =
		quote {(
			bslash (
				escapableChar
				| 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
				| (octalDigit [octalDigit] | zeroToThree octalDigit octalDigit)
			)
			| noQuote
		)} quote.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	classRef   = ".class".
	class      = "class".
	interface  = "interface".
	enum       = "enum".
	lpar       = '('.
	rpar       = ')'.
	lbrac      = '['.
	lbrace     = '{'.
	colon      = ':'.
	static     = "static".
	if         = "if".
	else       = "else".
	equals     = "=".
	new        = "new".
	this       = "this".
	return     = "return".
	yield      = "yield".

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE tab + cr + lf

PRODUCTIONS

Instrumenter = [PackageDecl] { Annotation | Class<false> | Enum<false> | ANY }.
PackageDecl = "package" (. ArrayList<String> packageName = new ArrayList<>(); .)
		ident 							(. packageName.add(t.val); .)
		{'.' ident 					(. packageName.add(t.val); .)
		}
		";" 								(. state.setPackageName(packageName); .)
		.
Annotation = "@" ident [ParExpr].
Class<boolean local> =
		("class" | "interface")	(. state.enterClass(false, local); .)
		ident {ANY} "{"
		ClassBody								(. state.leaveClass(); .)
	.
Enum<boolean local> =
	"enum"										(. state.enterClass(false, local); .)
	ident {ANY} "{"
	{[","] ident [ParExpr]}
	(";" ClassBody						// class body can follow only after a ";"
		| "}") 									(. state.leaveClass(); .)
	.
ClassBody =
	{ Enum<false> | Class<false>
		| "=" (BraceExpr | {ANY} Statement)
		| IF(state.identAndLPar()) MethodDecl
		| IF(state.staticAndLBrace()) StaticBlock
		| Annotation
		| ANY
	}
	"}"
.
StaticBlock =	static Block<false>.
MethodDecl =
		ident 											(. state.enterMethod(); .)
		ParExpr {ANY} (";"					(. state.leaveMethod(); .)
			| Block<true>
			)
		.
Statement =
		if ParExpr BlockOrSingleStatement [else BlockOrSingleStatement]
		| SwitchStatement
		| "while" ParExpr BlockOrSingleStatement
 		| "do" BlockOrSingleStatement "while" ParExpr ";"
		| "for" ParExpr BlockOrSingleStatement
		| "try" [ParExpr] Block<false> {"catch" ParExpr Block<false>} ["finally" Block<false>]
		| ("break" | "continue") {ANY} ";"
		| ("return" | "yield") (SwitchStatement | {ANY}) ";"
		| IF(state.isLabel()) ident colon
		| Annotation
		| "super" (ParExpr ";" (. state.markEndOfSuperCall(); .) | "." {ANY} ";")
		| IF(state.thisAndLPar()) this ParExpr ";" (. state.markEndOfSuperCall(); .)
		| ("++" | "--") ["("] ident [")"] ";"
		| "throw" ["new"] ident [ParExpr] ";" // TODO: investigate if needed
		| Class<true>
		| Enum<true>
		| GenericStatement
		| Block<false>
		| ";"
		.
GenericStatement =
	(ident | string | this | ParExpr | Instantiation)
		{string | char
			| ArrowExpression<false, false>
			| SwitchStatement
			| Instantiation
			| ANY
		} ";".
BlockOrSingleStatement =
		Block<false>
		| (. state.checkSingleStatement(false, false, false); .) Statement (. state.leaveSingleStatement(); .)
		.
SwitchStatement = 						(. boolean inAssignment = state.isAssignment(); .)
			"switch" ParExpr "{" {SwitchCase<inAssignment>}
			"}"
			.
SwitchCase<boolean inAssignment> =
	("case" | "default") {ANY}
	(ArrowExpression<true, inAssignment>
		| ":"											(. state.checkSingleStatement(false, true, false); .)
			{Statement}							(. state.leaveSingleStatement(); .)
	)
	.
ParExpr = "(" {ParExpr | ANY} ")".
BraceExpr = "{" {BraceExpr | ANY} "}".
BracketExpr = "[" {ANY} "]".
AngleBracketExpr = "<" {AngleBracketExpr | ANY} ">".
ArrowExpression<boolean inSwitch, boolean inAssignment> =
		"->" (Block<false> | SSArrowBody<inSwitch, inAssignment>)
	.
SSArrowBody<boolean inSwitch, boolean inAssignment> =
 																		(. state.checkSingleStatement(inAssignment, inSwitch, true); .)
				(ANY | ParExpr | string | char | ident | "throw" (. state.registerThrow(); .))
				{ANY | ParExpr}
				(")" | ";")									(. state.leaveSingleStatement(); .)
				.
Instantiation = "new" ident {["."] ident}
		(BracketExpr [BraceExpr] // array initializer
			| [AngleBracketExpr] ParExpr ["{" (. state.enterClass(true, false); .) ClassBody (. state.leaveClass();.)]
		)
		.
Block<boolean isMethod> = 					(. state.enterBlock(isMethod); .)
				"{" {Statement} "}"					(. state.leaveBlock(isMethod); .)
			.

END Instrumenter.
