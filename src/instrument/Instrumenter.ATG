COMPILER Instrumenter

	List<Block> allBlocks = new ArrayList<>();
	Stack<Block> blockStack = new Stack<>();
	String curClass = null;
	String curMeth = null;
	Block curBlock = null;

	static class Block {
	  String clazz;
	  String method;
	  int beg, end;
	  boolean isMethodBlock;

    public String toString() {
      return String.format("%s%s: {%d-%s}%s", clazz, method != null ? ("." + method) : "", beg, end != 0 ? end : "?", isMethodBlock ? " m" : "");
	  }
	  @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      Block block = (Block) o;
      if (beg != block.beg) return false;
      if (end != block.end) return false;
      if (isMethodBlock != block.isMethodBlock) return false;
      if (!Objects.equals(clazz, block.clazz)) return false;
      return Objects.equals(method, block.method);
    }

    @Override
    public int hashCode() {
      int result = clazz != null ? clazz.hashCode() : 0;
      result = 31 * result + (method != null ? method.hashCode() : 0);
      result = 31 * result + beg;
      result = 31 * result + end;
      result = 31 * result + (isMethodBlock ? 1 : 0);
      return result;
    }
	}

	void enterClass() {
		curClass = t.val;
		System.out.printf("entering class <%s>\n", curClass);
	}

	void leaveClass() {
		System.out.printf("left class <%s>\n", curClass);
		curClass = null;
	}

	void checkForMethodDeclaration() {
		if (curMeth != null) return;
		if (t.kind == _ident && la.kind == _lpar) {
			curMeth = t.val;
			System.out.println("found method declaration of: " + curMeth);
		}
		else if (t.kind == _static && la.kind == _lbrace) {
			curMeth = t.val;
			System.out.println("found static block");
		}
	}

	void enterMethod() {
		curMeth = t.val;
		System.out.println("found method declaration of: " + curMeth);
	}

	void leaveMethod() {
		curBlock.isMethodBlock = true;
		System.out.println("left method: " + curMeth);
		curMeth = null;
	}

	void enterStaticBlock() {
		curMeth = t.val;
		System.out.println("found static block");
  }

	void leaveStaticBlock() {
		System.out.println("left static block");
		curMeth = null;
	}

	void enterBlock() {
		if (curBlock != null) {
			blockStack.push(curBlock);
		}
		curBlock = new Block();
		curBlock.clazz = curClass;
		curBlock.method = curMeth;
		curBlock.beg = t.line;
		allBlocks.add(curBlock);
		System.out.printf("entering block %s\n", curBlock);
	}

	void leaveBlock() {
		curBlock.end = t.line;
		System.out.printf("left block %s\n", curBlock);
		if (blockStack.empty()) {
			if ("static".equals(curMeth)) {
				leaveStaticBlock();
			} else {
				leaveMethod();
			}
			curBlock = null;
		} else {
			curBlock = blockStack.pop();
		}
	}

	boolean identAndLPar() {
		return t.kind == _ident && la.kind == _lpar;
	}

	boolean staticAndLBrace() {
		return t.kind == _static && la.kind == _lbrace;
	}

CHARACTERS
	letter = 'a' .. 'z' + 'A'..'Z'.
	digit  = '0'..'9'.
TOKENS
	ident  = letter {letter | digit | '_'}.
	// .. weitere Java-Token einfügen und eventuell die dazu nötigen Zeichenklassen
	lpar   = '('.
	lbrace = '{'.
	static = "static".
IGNORE "\t\n\r"

PRODUCTIONS

Instrumenter = { {ANY} Class }.
Class =
			"class" ident						(. enterClass(); .)
			{ANY} "{"
			{ Class
				| "abstract" ident {ANY} ";"
				| IF(identAndLPar()) MethodDecl
				| IF(staticAndLBrace()) StaticBlock
				| ANY
			}
			"}"											(. leaveClass(); .)
		.
StaticBlock =									(. enterStaticBlock(); .)
						Block.
MethodDecl  =									(. enterMethod(); .)
						BracketExpr Block.
Statement =
		"if" BracketExpr Statement ["else" Statement]
		| "switch" BracketExpr "{"
			{"case" {ANY} ":" {Statement}}
			["default" ":" {Statement}]
			"}"
		| "while" BracketExpr Statement
		| "do" Statement "while" BracketExpr ";"
		| "for" BracketExpr Statement
		| "try" Block {"catch" BracketExpr Block} ["finally" Block]
		| ("break" | "return" | "continue") {ANY} ";"
		| ident ({ANY | QuotedText | "->" Statement} ";" | ":")
		| Block
		| ";" .
QuotedText = '"' {ANY} '"'.
BracketExpr = "(" {BracketExpr | ANY} ")".
Block = "{"										(. enterBlock(); .)
				{Statement}
				"}"										(. leaveBlock(); .)
			.

END Instrumenter.
